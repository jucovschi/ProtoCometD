package info.kwarc.net.cometd;

import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.cometd.bayeux.server.BayeuxServer;
import org.cometd.bayeux.server.ServerChannel;
import org.cometd.bayeux.server.ServerMessage.Mutable;
import org.cometd.bayeux.server.ServerSession;
import org.cometd.server.AbstractService;
import org.cometd.server.BayeuxServerImpl;
import org.eclipse.jetty.util.thread.ThreadPool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.protobuf.AbstractMessage;

/**
 * Extension of CometD services allowing services to filter the type of
 * messages they receive and the sender of the message. 
 * @author cjucovschi
 *
 */
public class ProtoService extends AbstractService {
	private final BayeuxServerImpl _bayeux;
	private final String _name;
    private final Map<String, TypedInvoker> invokers = new ConcurrentHashMap<String, TypedInvoker>();
    protected final Logger _logger = LoggerFactory.getLogger(getClass());

	public ProtoService(BayeuxServer bayeux, String name) {
		super(bayeux, name);
		_bayeux = (BayeuxServerImpl) bayeux;
		_name = name;
	}

	protected void addService(String channelName, String methodName, Class<?> [] objectTypes, ISenderValidator validator) {
		_logger.debug("Mapping {}#{} to {}", new Object[]{_name, methodName, channelName});

		if (objectTypes == null) {
			objectTypes = new Class<?> [0];
		}
		Method method = null;

		Class<?> c = this.getClass();
		while (c != null && c != Object.class)
		{
			Method[] methods = c.getDeclaredMethods();
			for (int i = methods.length; i-- > 0; )
			{
				if (methodName.equals(methods[i].getName()))
				{
					if (method != null)
						throw new IllegalArgumentException("Multiple methods called '" + methodName + "'");
					method = methods[i];
				}
			}
			c = c.getSuperclass();
		}

		if (method == null)
			throw new NoSuchMethodError(methodName);
		int params = method.getParameterTypes().length;
		int expectedNumber = validator != null? 4:3;
		if (params != expectedNumber)
			throw new IllegalArgumentException("Method '" + methodName + "' does not have "+expectedNumber+" parameters");
		if (!ServerSession.class.isAssignableFrom(method.getParameterTypes()[0]))
			throw new IllegalArgumentException("Method '" + methodName + "' does not have Session as first parameter");
		if (!String.class.isAssignableFrom(method.getParameterTypes()[1]))
			throw new IllegalArgumentException("Method '" + methodName + "' does not have String as second parameter");
		if (!AbstractMessage.class.isAssignableFrom(method.getParameterTypes()[2]))
			throw new IllegalArgumentException("Method '" + methodName + "' does not have AbstractMessage as third parameter");
		
		_bayeux.createIfAbsent(channelName);
		ServerChannel channel = _bayeux.getChannel(channelName);
		TypedInvoker invoker = new TypedInvoker(channelName, method, objectTypes, validator);
		invokers.put(methodName, invoker);
		channel.addListener(invoker);	
	}
	
    /**
     * <p>Unmaps the method with the given name that has been mapped to the given channel.</p>
     *
     * @param channelName The channel name
     * @param methodName  The name of the method to unmap
     * @see #addService(String, String)
     * @see #removeService(String)
     */
    protected void removeService(String channelName, String methodName)
    {
        ServerChannel channel = _bayeux.getChannel(channelName);
        if (channel != null)
        {
            TypedInvoker invoker = invokers.remove(methodName);
            channel.removeListener(invoker);
        }
    }

    /**
     * <p>Unmaps all the methods that have been mapped to the given channel.</p>
     *
     * @param channelName The channel name
     * @see #addService(String, String)
     * @see #removeService(String, String)
     */
    protected void removeService(String channelName)
    {
        ServerChannel channel = _bayeux.getChannel(channelName);
        if (channel != null)
        {
            for (TypedInvoker invoker : invokers.values())
            {
                if (invoker.channelName.equals(channelName))
                    channel.removeListener(invoker);
            }
        }
    }
    
    protected void doInvoke(Method method, ServerSession fromClient, String channel, AbstractMessage msg, String messageid, Object src)
    {
        if (method != null)
        {
            try
            {

                boolean accessible = method.isAccessible();
                Object reply = null;
                try
                {
                    method.setAccessible(true);
                    if (src == null)
                    	reply = method.invoke(this, fromClient, channel, msg);
                    else
                    	reply = method.invoke(this, fromClient, channel, msg, src);
                    if (reply != null && !(reply instanceof AbstractMessage) ) {
                        exception(method.toString(), fromClient, getLocalSession(), null, new Exception("Return value is not a protobuffer object"));
                        reply = CommUtils.prepareProto((AbstractMessage)reply);
                    }
                }
                finally
                {
                    method.setAccessible(accessible);
                }

                if (reply != null)
                    send(fromClient, channel, reply, messageid);
            }
            catch (Exception e)
            {
                exception(method.toString(), fromClient, getLocalSession(), null, e);
            }
            catch (Error e)
            {
                exception(method.toString(), fromClient, getLocalSession(), null, e);
            }
        }
    }

    private void invoke(final Method method, final ServerSession fromClient, final String channelid, final AbstractMessage msg, final String messageid, final Object src)
    {
        ThreadPool threadPool = getThreadPool();
        if (threadPool == null)
            doInvoke(method, fromClient, channelid, msg, messageid, src);
        else
        {
            threadPool.dispatch(new Runnable()
            {
                public void run()
                {
                    doInvoke(method, fromClient, channelid, msg, messageid, src);
                }
            });
        }
    }

	private class TypedInvoker implements ServerChannel.MessageListener
    {
        private final String channelName;
        private final Method method;
        private final Class<?> [] objectTypes;
        private final ISenderValidator validator;
        
        public TypedInvoker(String channelName, Method method, Class<?> [] objectTypes, ISenderValidator validator)
        {
            this.channelName = channelName;
            this.method = method;
            this.objectTypes = objectTypes;
            this.validator = validator;
        }

        public boolean onMessage(ServerSession from, ServerChannel channel, Mutable message)
        {
            if (isSeeOwnPublishes() || from != getServerSession()) {
            	AbstractMessage msg = CommUtils.createProto(message);
            	// check if it parses into a protobuffer
            	if (msg == null) {
                	_logger.debug("Unparsable message from {}", new Object[] {message.getChannel()});
            		return true;
            	}

            	// check if it has at least one of the types
            	if (objectTypes.length > 0) {
                	boolean found = false;
                	for (Class<?> cls : objectTypes) {
                		if (cls.isAssignableFrom(msg.getClass())) {
                			found = true;
                    		break;
                		}
                	}
                	if (!found) {
                    	_logger.debug("Wrongly typed message {} came to {}", new Object[] {msg, message.getChannel()});
                		return true;
                	}
            	}
            	Object src = null;
            	// check if it comes from the right source
            	if (validator != null) {
            		src = validator.isValid(from.getId());
            		if (src == null) {
                    	_logger.debug("Source check failed for message from {}", new Object[] {message.getChannel()});
            			return true;
            		}
            	}
            	_logger.debug("Invoking for {}", new Object[] {msg});

                invoke(method, from, message.getChannel(), msg, message.getId(), src);
            }
            return true;
        }
    }
}
